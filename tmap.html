
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>T-MAP – Скрити/показани слоеве + детайлни карти + коментари</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    html, body { height: 100%; margin: 0; background: #f7f7fb; }
    #map { height: 100%; width: 100%; }

    .leaflet-popup-content-wrapper { max-width: 320px !important; padding: 8px; }
    .leaflet-popup-content { max-width: 320px !important; font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .popup-title { font-weight: 700; margin-bottom: 6px; }
    .popup-img { display:block; max-width:100%; height:auto; border-radius:8px; margin-top:8px; box-shadow:0 2px 8px rgba(0,0,0,.15); }

    .visit-badge { background: transparent; border: none; }
    .visit-badge .badge {
      display: inline-block;
      min-width: 14px; height: 14px; padding: 0 4px;
      border-radius: 999px; background: #ffffff;
      border: 1px solid #e0e0e0; box-shadow: 0 2px 6px rgba(0,0,0,.15);
      font-size: 10px; line-height: 14px; text-align: center;
      user-select: none; pointer-events: none;
    }

    .authbar {
      position: fixed; top: 10px; right: 10px; z-index: 10001;
      display: flex; align-items: center; gap: 10px;
      background: rgba(255,255,255,0.92); backdrop-filter: blur(6px);
      border: 1px solid rgba(0,0,0,0.08); border-radius: 999px;
      padding: 6px 10px; box-shadow: 0 8px 22px rgba(0,0,0,.12);
      font: 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .authbar button {
      appearance: none; border: 0; border-radius: 999px; padding: 8px 12px;
      font-weight: 700; cursor: pointer;
    }
    .btn-primary { background: #0ea5e9; color: #fff; box-shadow: 0 6px 16px rgba(14,165,233,.35); }
    .btn-ghost   { background: transparent; color: #0f172a; border: 1px solid rgba(0,0,0,0.08); }
    .auth-avatar { width: 28px; height: 28px; border-radius: 999px; object-fit: cover; box-shadow: 0 0 0 1px rgba(0,0,0,.08); display:none; }

    .cmt-wrap { margin-top: 10px; border-top: 1px dashed #e2e8f0; padding-top: 8px; }
    .cmt-title { font-weight: 700; margin-bottom: 6px; color: #0f172a; }
    .cmt-item { display:flex; gap:8px; padding:6px 0; border-bottom: 1px dashed #eef2f7; }
    .cmt-item:last-child { border-bottom: 0; }
    .cmt-avatar { width:24px; height:24px; border-radius:999px; background:#e2e8f0; color:#334155; font-weight:700; display:grid; place-items:center; }
    .cmt-meta { font-size:12px; color:#64748b; }
    .cmt-content { white-space: pre-wrap; word-break: break-word; }

    .cmt-form { display:grid; gap:6px; margin-top:8px; }
    .cmt-form textarea {
      width:100%; min-height:60px; resize:vertical; padding:8px 10px;
      border:1px solid #e2e8f0; border-radius:10px; background:#fff;
      font: 13px/1.45 system-ui;
    }
    .cmt-form button { justify-self: end; }
    .muted { color:#94a3b8; font-size:12px; }

    /* Контрол за скриване/показване на панела със слоевете */
    .leaflet-control.tmap-layers-toggle button {
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 10px; padding: 8px 10px; cursor: pointer;
      font: 12px/1.2 system-ui; box-shadow: 0 6px 16px rgba(0,0,0,.12);
    }
    .leaflet-control-layers.tmap-layers-panel {
      transition: transform .18s ease, opacity .18s ease;
      will-change: transform, opacity;
      margin-bottom: 8px;
    }
    .leaflet-control-layers.tmap-hidden {
      transform: translateY(6px);
      opacity: 0; pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="authbar" id="authbar">
    <span id="authStatus" class="muted">Не сте влезли</span>
    <img id="authAvatar" class="auth-avatar" alt="">
    <button id="signInBtn" class="btn-primary">Вход с Gmail</button>
    <button id="signOutBtn" class="btn-ghost" style="display:none;">Изход</button>
  </div>

  <script>
    const SUPABASE_URL = "https://cmiylzpmpwqbacjoqtkx.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNtaXlsenBtcHdxYmFjam9xdGt4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM5ODcwMDUsImV4cCI6MjA2OTU2MzAwNX0.FY2d1NSGTmw6SydxT_V0cKF7Kp2USbp91VdfO_eqZz8";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true },
      realtime: { headers: {} }
    });

    // ---------- Auth UI ----------
    let currentUser = null;
    async function refreshAuthUI() {
      const { data: { user } } = await supabase.auth.getUser();
      currentUser = user || null;
      const status = document.getElementById('authStatus');
      const avatar = document.getElementById('authAvatar');
      const signInBtn = document.getElementById('signInBtn');
      const signOutBtn = document.getElementById('signOutBtn');
      if (currentUser) {
        const name = currentUser.user_metadata?.full_name || currentUser.email || 'Потребител';
        const img = currentUser.user_metadata?.avatar_url;
        status.textContent = 'Влязохте като ' + name;
        if (img) { avatar.src = img; avatar.style.display = 'block'; } else { avatar.style.display = 'none'; }
        signInBtn.style.display = 'none';
        signOutBtn.style.display = 'inline-block';
      } else {
        status.textContent = 'Не сте влезли';
        avatar.style.display = 'none';
        signInBtn.style.display = 'inline-block';
        signOutBtn.style.display = 'none';
      }
    }
    document.getElementById('signInBtn').addEventListener('click', async () => {
      await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: { queryParams: { access_type: 'offline', prompt: 'consent' }, redirectTo: window.location.href }
      });
    });
    document.getElementById('signOutBtn').addEventListener('click', async () => {
      await supabase.auth.signOut();
      await refreshAuthUI();
    });
    supabase.auth.onAuthStateChange((_event, _session) => { refreshAuthUI(); });

    // ---------- Base layers ----------
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' });
    const positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap contributors &copy; CARTO' });
    const opentopo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: 'Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap (CC-BY-SA)' });
    const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri &mdash; Source: Esri, Maxar, Earthstar Geographics, GIS User Community' });
    const cyclOSM = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', { attribution: 'Map data: &copy; OpenStreetMap contributors | Style: CyclOSM' });

    // ---------- Overlay thematic layers ----------
    const hiking = L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', { opacity: 0.9, attribution: 'Hiking overlay &copy; waymarkedtrails.org' });
    const hillshade = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}', { opacity: 0.55, attribution: 'Hillshade &copy; Esri' });
    const railways = L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', { opacity: 0.6, attribution: '&copy; OpenRailwayMap contributors' });
    const ski = L.tileLayer('https://tiles.openskimap.org/openskimap/{z}/{x}/{y}.png', { opacity: 0.8, attribution: '&copy; OpenSkiMap' });

    // ---------- Map init ----------
    const map = L.map('map', {
      center: [42.7339, 25.4858],
      zoom: 7,
      layers: [opentopo] // по подразбиране детайлен терен
    });

    // Scale control
    L.control.scale({ metric: true, imperial: false }).addTo(map);

    const baseLayers = {
      'OpenTopoMap (детайлен терен)': opentopo,
      'ESRI Сателит': esriSat,
      'OSM Стандарт': osm,
      'Carto Positron (светъл)': positron,
      'CyclOSM (колоездене)': cyclOSM
    };
    const overlays = {
      'Туристически пътеки (Waymarked Trails)': hiking,
      'Релеф (Hillshade)': hillshade,
      'ЖП линии (OpenRailwayMap)': railways,
      'Ски курорти (OpenSkiMap)': ski
    };
    const layerCtl = L.control.layers(baseLayers, overlays, { collapsed: true, position: 'bottomright' }).addTo(map);

    // Достъп до елемента и анимационно скриване/показване + запомняне в localStorage
    function getLayersPanelEl() {
      const el = document.querySelector('.leaflet-control-layers');
      if (el && !el.classList.contains('tmap-layers-panel')) {
        el.classList.add('tmap-layers-panel');
      }
      return el;
    }
    function applyLayersVisibilityFromStorage() {
      const el = getLayersPanelEl();
      if (!el) return;
      const hidden = localStorage.getItem('tmap_layers_hidden') === '1';
      el.classList.toggle('tmap-hidden', hidden);
    }
    function toggleLayersVisibility() {
      const el = getLayersPanelEl();
      if (!el) return;
      const nowHidden = !el.classList.toggle('tmap-hidden'); // toggle returns boolean if class present after op; we want inverse
      // Correction of logic: compute hidden = el.classList.contains('tmap-hidden')
      const hidden = el.classList.contains('tmap-hidden');
      localStorage.setItem('tmap_layers_hidden', hidden ? '1' : '0');
    }

    // Контрол – бутон „Слоеве“ за show/hide
    const LayersToggle = L.Control.extend({
      options: { position: 'bottomright' },
      onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-control tmap-layers-toggle');
        const btn = L.DomUtil.create('button', '', container);
        btn.type = 'button';
        btn.title = 'Покажи/скрий панела за слоеве';
        btn.innerHTML = 'Слоеве';
        L.DomEvent.disableClickPropagation(container);
        btn.addEventListener('click', function(e){ e.preventDefault(); toggleLayersVisibility(); });
        return container;
      }
    });
    map.addControl(new LayersToggle());

    // ---------- Останалите функции (маркери, посещения, коментари, realtime) ----------
    const ICON_URL = 'logo01082025.svg';
    const customIcon = L.icon({ iconUrl: ICON_URL, iconSize: [52, 52], iconAnchor: [26, 48], popupAnchor: [0, -40], className: 'tmap-pin' });

    const markersById = new Map();
    const badgeRefs = new Map();
    const visitCountCache = new Map();
    const openCommentContainers = new Map(); // objectId -> wrapEl

    async function getVisitCount(objectId) {
      const cached = visitCountCache.get(objectId);
      if (typeof cached === 'number') return cached;
      const { count, error } = await supabase.from('visits').select('*', { count: 'exact', head: true }).eq('object_id', objectId);
      const safe = error ? 0 : (count || 0);
      visitCountCache.set(objectId, safe);
      return safe;
    }
    async function markVisit(objectId) {
      const { error } = await supabase.from('visits').insert([{ object_id: objectId, client_id: getClientId() }]);
      if (error) return { ok:false, reason:'already_marked' };
      const next = (visitCountCache.get(objectId) || 0) + 1;
      visitCountCache.set(objectId, next);
      updateBadge(objectId, next);
      return { ok:true };
    }
    function createBadgeMarker(lat, lng, initial) {
      const html = '<span class="badge">' + initial + '</span>';
      const icon = L.divIcon({ className: 'visit-badge', html, iconSize: [1,1], iconAnchor: [42, 20] });
      return L.marker([lat, lng], { icon, interactive: false, zIndexOffset: 250 });
    }
    function updateBadge(objectId, value) { const ref = badgeRefs.get(objectId); if (ref) { const el = ref.getElement(); if (!el) return; const span = el.querySelector('.badge'); if (span) span.textContent = String(value); } }

    function getClientId() {
      const k = 'tmap_client_id';
      let id = localStorage.getItem(k);
      if (!id) {
        id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now()) + Math.random();
        localStorage.setItem(k, id);
      }
      return id;
    }

    // Коментари
    function escapeHtml(str) { return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
    function initials(name) { const parts = String(name || '??').trim().split(/\s+/).slice(0,2); return parts.map(p => p[0]?.toUpperCase() || '').join('') || 'U'; }
    function fmtDate(iso) { try { const d = new Date(iso); return d.toLocaleString('bg-BG', { dateStyle:'short', timeStyle:'short' }); } catch { return ''; } }

    async function loadComments(objectId) {
      const { data, error } = await supabase.from('comments').select('*').eq('object_id', objectId).order('created_at', { ascending: true });
      if (error) return []; return data || [];
    }
    async function addComment(objectId, text) {
      if (!currentUser) throw new Error('not-auth');
      const username = currentUser.user_metadata?.full_name || currentUser.email || 'Потребител';
      const user_id = currentUser.id;
      const payload = { object_id: String(objectId), user_id, username, comment: text };
      const { data, error } = await supabase.from('comments').insert([payload]).select().single();
      if (error) throw error; return data;
    }
    function renderComments(container, comments) {
      const list = container.querySelector('.cmt-list');
      if (!list) return;
      if (!comments.length) { list.innerHTML = '<div class="muted">Все още няма коментари.</div>'; return; }
      list.innerHTML = comments.map(c => {
        const name = escapeHtml(c.username || 'Потребител');
        const when = c.created_at ? fmtDate(c.created_at) : '';
        const txt = escapeHtml(c.comment || '');
        return '<div class="cmt-item">\
          <div class="cmt-avatar">'+ initials(name) +'</div>\
          <div>\
            <div class="cmt-meta">'+ name +' · '+ when +'</div>\
            <div class="cmt-content">'+ txt +'</div>\
          </div>\
        </div>';
      }).join('');
    }
    async function attachCommentsUI(containerEl, objectId) {
      if (containerEl.querySelector('.cmt-wrap')) return;
      const wrap = document.createElement('div');
      wrap.className = 'cmt-wrap';
      wrap.dataset.oid = objectId;
      wrap.innerHTML = '<div class="cmt-title">Коментари</div>\
        <div class="cmt-list muted">Зареждане...</div>\
        <div class="cmt-form-block"></div>';
      containerEl.appendChild(wrap);

      const comments = await loadComments(String(objectId));
      renderComments(wrap, comments);

      const block = wrap.querySelector('.cmt-form-block');
      if (currentUser) {
        block.innerHTML = '<form class="cmt-form" data-oid="'+objectId+'">\
          <textarea name="content" maxlength="1000" placeholder="Напишете коментар... (до 1000 знака)"></textarea>\
          <button type="submit" class="btn-primary">Публикувай</button>\
          <div class="muted cmt-msg"></div>\
        </form>';
        const form = block.querySelector('form');
        const msg = block.querySelector('.cmt-msg');
        form.addEventListener('submit', async (e) => {
          e.preventDefault();
          const text = (form.content.value || '').trim();
          if (!text) { msg.textContent = 'Коментарът е празен.'; return; }
          if (text.length > 1000) { msg.textContent = 'Прекалено дълъг коментар.'; return; }
          msg.textContent = 'Публикуване...';
          try { await addComment(String(objectId), text); form.reset(); msg.textContent = 'Публикувано.'; }
          catch (err) { msg.textContent = 'Грешка при публикуване.'; }
        });
      } else {
        block.innerHTML = '<div class="muted">За да коментирате, влезте с Gmail отгоре вдясно.</div>';
      }

      openCommentContainers.set(String(objectId), wrap);
    }

    // Попъпи и маркери
    function bindPopupToMarker(marker, obj) {
      marker.bindPopup('<div id="popup-'+obj.id+'">\
        <div class="popup-title">'+ (obj.title ? escapeHtml(obj.title) : 'Без заглавие') +'</div>\
        '+ (obj.description ? '<div>'+ escapeHtml(obj.description) +'</div>' : '') +'\
        '+ (obj.image_url ? '<img class="popup-img" src="'+ escapeHtml(String(obj.image_url)) +'" alt="">' : '') +'\
      </div>');
      marker.on('popupopen', async () => {
        const container = document.getElementById('popup-' + obj.id);
        if (!container) return;
        await attachVisitUIToPopup(container, String(obj.id));
        await attachCommentsUI(container, String(obj.id));
      });
    }

    async function addMarker(obj) {
      const lat = Number(obj.latitude), lng = Number(obj.longitude);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
      const marker = L.marker([lat, lng], { icon: customIcon }).addTo(map);
      markersById.set(String(obj.id), marker);
      bindPopupToMarker(marker, obj);
      const initial = await getVisitCount(String(obj.id));
      const badge = createBadgeMarker(lat, lng, initial).addTo(map);
      badgeRefs.set(String(obj.id), badge);
    }

    async function loadObjects() {
      const { data, error } = await supabase.from('objects').select('*').order('created_at', { ascending: true });
      if (error) { console.error(error); return; }
      for (const obj of (data || [])) { await addMarker(obj); }
    }

    // Реално време
    function subscribeRealtime() {
      supabase.channel('rt:objects')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'objects' }, async (payload) => {
          const obj = payload.new; await addMarker(obj);
        })
        .subscribe();

      supabase.channel('rt:comments')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'comments' }, async (payload) => {
          const row = payload.new; const oid = String(row.object_id);
          const wrap = openCommentContainers.get(oid);
          if (wrap) { const now = await loadComments(oid); renderComments(wrap, now); }
        })
        .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'comments' }, async (payload) => {
          const row = payload.old; const oid = String(row.object_id);
          const wrap = openCommentContainers.get(oid);
          if (wrap) { const now = await loadComments(oid); renderComments(wrap, now); }
        })
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'comments' }, async (payload) => {
          const row = payload.new; const oid = String(row.object_id);
          const wrap = openCommentContainers.get(oid);
          if (wrap) { const now = await loadComments(oid); renderComments(wrap, now); }
        })
        .subscribe();
    }

    // Visits UI
    async function attachVisitUIToPopup(containerEl, objectId) {
      if (containerEl.querySelector('.tmap-visit')) return;
      const count = await getVisitCount(objectId);
      containerEl.insertAdjacentHTML('beforeend',
        '<div class="tmap-visit" data-oid="' + objectId + '">\
            <div class="tmap-visit-row" style="margin-bottom:6px;">Посетили: <strong>' + count + '</strong> души</div>\
            <button class="btn-ghost tmap-visit-btn">Отбележи се</button>\
            <div class="muted tmap-visit-msg"></div>\
          </div>'
      );
      const root = containerEl.querySelector('.tmap-visit[data-oid="' + objectId + '"]');
      const btn  = root.querySelector('.tmap-visit-btn');
      const msg  = root.querySelector('.tmap-visit-msg');
      const cntEl= root.querySelector('.tmap-visit-row strong');
      btn.addEventListener('click', async () => {
        btn.disabled = true;
        msg.textContent = 'Обработвам...';
        const res = await markVisit(objectId);
        if (res.ok) {
          cntEl.textContent = String(parseInt(cntEl.textContent, 10) + 1);
          msg.textContent = 'Успешно се отбелязахте!';
        } else if (res.reason === 'already_marked') {
          msg.textContent = 'Вече сте се отбелязали тук от това устройство.';
        } else {
          msg.textContent = 'Възникна грешка. Опитайте по-късно.';
        }
        btn.disabled = false;
      }, { passive: true });
    }

    (async function init() {
      await refreshAuthUI();
      await loadObjects();
      subscribeRealtime();
      // Приложи видимостта на панела според localStorage (по подразбиране: видим)
      applyLayersVisibilityFromStorage();
    })();
  </script>
</body>
</html>
