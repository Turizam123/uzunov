
/*! lite togeojson fallback (GPX/KML -> GeoJSON)
 *  Supports: GPX trk/trkseg/trkpt, GPX rte/rtept, KML Placemark LineString, KML gx:Track.
 *  Not a full replacement for mapbox/togeojson, but sufficient for simple tracks.
 *  Public API: window.toGeoJSON.gpx(xml), window.toGeoJSON.kml(xml)
 */
(function(g){
  "use strict";
  function q(el, sel){ return el.querySelector(sel); }
  function qa(el, sel){ return Array.prototype.slice.call(el.querySelectorAll(sel)); }
  function txt(el){ return el && (el.textContent || el.innerText) || ""; }
  function num(x){ var v=parseFloat(x); return isFinite(v)?v:null; }

  function feature(ls, name){
    return { type:"Feature", properties:{ name: name || "" }, geometry:{ type:"LineString", coordinates: ls } };
  }
  function fc(arr){ return { type:"FeatureCollection", features: arr||[] }; }

  function parseCoordsString(s){
    var out=[], t = (s||"").trim().replace(/\s+/g," ").split(" ");
    for (var i=0;i<t.length;i++){
      var p=t[i].split(",");
      if (p.length>=2){
        var lon=num(p[0]), lat=num(p[1]);
        if (lon!=null && lat!=null) out.push([lon,lat]);
      }
    }
    return out;
  }

  function gpx(xml){
    var feats=[], name;
    // Tracks
    qa(xml, "trk").forEach(function(trk){
      name = txt(q(trk,"name")) || "GPX Track";
      qa(trk, "trkseg").forEach(function(seg){
        var ls = [];
        qa(seg, "trkpt").forEach(function(pt){
          var lat=num(pt.getAttribute("lat")), lon=num(pt.getAttribute("lon"));
          if (lat!=null && lon!=null) ls.push([lon,lat]);
        });
        if (ls.length>=2) feats.push(feature(ls, name));
      });
    });
    // Routes
    qa(xml, "rte").forEach(function(rte){
      name = txt(q(rte,"name")) || "GPX Route";
      var ls = [];
      qa(rte, "rtept").forEach(function(pt){
        var lat=num(pt.getAttribute("lat")), lon=num(pt.getAttribute("lon"));
        if (lat!=null && lon!=null) ls.push([lon,lat]);
      });
      if (ls.length>=2) feats.push(feature(ls, name));
    });
    return fc(feats);
  }

  function kml(xml){
    var feats=[];
    qa(xml, "Placemark").forEach(function(pm){
      var name = txt(q(pm,"name")) || "KML";
      // LineString
      var lsNode = q(pm, "LineString");
      if (lsNode){
        var cNode = q(lsNode, "coordinates");
        if (cNode){
          var ls = parseCoordsString(txt(cNode));
          if (ls.length>=2) feats.push(feature(ls, name));
        }
      }
      // gx:Track (space-separated "lon lat [alt]")
      var tracks = qa(pm, "gx\\:Track, Track");
      tracks.forEach(function(tr){
        var ls = [];
        qa(tr, "gx\\:coord, coord").forEach(function(c){
          var parts = txt(c).trim().split(/\s+/);
          if (parts.length>=2){
            var lon=num(parts[0]), lat=num(parts[1]);
            if (lon!=null && lat!=null) ls.push([lon,lat]);
          }
        });
        if (ls.length>=2) feats.push(feature(ls, name));
      });
    });
    return fc(feats);
  }

  g.toGeoJSON = g.toGeoJSON || {};
  g.toGeoJSON.gpx = gpx;
  g.toGeoJSON.kml = kml;
})(this);
